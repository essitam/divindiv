<html>
<head>
<title>Sketchpad</title>

	

<script type="text/javascript">
    // Variables for referencing the canvas and 2dcanvas context
    var canvas,ctx,ctx2;

    // Variables to keep track of the mouse position and left-button status 
    var mouseX,mouseY,mouseDown=0;

    // Variables to keep track of the touch position
    var touchX,touchY;

    // Keep track of cycling through different hues each time a dot is drawn
    //var hue=360 * Math.random();
	
	///this works but doesn't cycle through

    // Draws a dot at a specific position on the supplied canvas name
    // Parameters are: A canvas context, the x position, the y position, the size of the dot
    function drawDot(ctx,x,y,size) {
	// Instead of using RGB (red/green/blue) format for the drawing colour, since we're cycling through
	// hue values, it makes more sense to use HSLA, which is Hue, Saturation, Luminence
	// We can use fixed values for Saturation, Luminence and alpha, and just use the Hue value from our hue variable.
    var sat= 85; 
	var	lum= 20 + (60 * Math.random()); //this is the most important random to use as unless you can get low numbers, there will be no browns. but you need it to be jumping in the ranges
		var hue2= 360 * Math.random();
		
		//var hue2= 150 + (200 * Math.random()); this helps me select what spectrum of color. the first number is the base of where things will start, and then random from there. 
		
		//var hue2= 255 * Math.random();
	//var	a=90; //
		
		a = 1.0;
		//a = 0.1 + (0.9* Math.random()); this gives the best alpha variances with each mouse down step. 

        // Select a fill style
        ctx.fillStyle = "hsla("+hue2+","+sat+"%,"+lum+"%,"+a+")";
		
		//"hsla("360 * Math.random()", 90%, 50%,"+(a/255)+")";
		

        // Draw a filled circle
        ctx.beginPath();
		
        //ctx.arc(x, y, size, 0, Math.PI*2, true); 
		//the above was the original code to draw a circle
		//changing this to ctx.rect didn't work --- but using fillRect did. the numbers are xlocation, ylocation, width, and height. 
		 
		
		//ctx.lineTo(e.clientX, e.clientY);
        ctx.closePath();
		
		var rectsize = 10 + (20* Math.random());
		
		ctx.fillRect( mouseX - (80* Math.random()), mouseY -   (80*Math.random()),rectsize,rectsize);
		
		// Update the hue - increase the "2" value here for a faster cycle through the different colours
	//hue2+=255 * Math.random();

	// Go back to the first hue if we've reached the end of the hue range
	//if (hue>360) 
	 //hue=0;
    } 



	
	function drawDot2(ctx2,x,y,size) {
	// Instead of using RGB (red/green/blue) format for the drawing colour, since we're cycling through
	// hue values, it makes more sense to use HSLA, which is Hue, Saturation, Luminence
	// We can use fixed values for Saturation, Luminence and alpha, and just use the Hue value from our hue variable.
         sat=100; lum=50; a=255;

        // Select a fill style
        ctx2.fillStyle = "#999999";
		///this is where it's cycling through colors.

        // Draw a filled circle
        ctx2.beginPath();
        ctx2.arc(x, y, 2, 0, Math.PI*2, true); 
        ctx2.closePath();
        ctx2.fill();
		
		 //ctx2.fillRect(x,0,5,100);
		
		
		
        //ctx.fillRect();

	// Update the hue - increase the "2" value here for a faster cycle through the different colours
	hue+=1;

	// Go back to the first hue if we've reached the end of the hue range
	if (hue>360) 
	 hue=0;
    } 

	
	
	
	
	
	
    // Clear the canvas context using the canvas width and height
    function clearCanvas(canvas,ctx) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
		ctx2.clearRect(0, 0, canvas.width, canvas.height);
    }

    // Keep track of the mouse button being pressed and draw a dot at current location
    function sketchpad_mouseDown() {
        mouseDown=1;
        drawDot(ctx,mouseX,mouseY,10);
		//drawDot2(ctx2,mouseX,mouseY,20);
		//i increased this value from 10 to 20. now the first dot drawn is twice the size of the copy ones. 
		
    }

    // Keep track of the mouse button being released
    function sketchpad_mouseUp() {
        mouseDown=0;
		drawDot2(ctx2,mouseX,mouseY,10);
    }

    // Keep track of the mouse position and draw a dot if mouse button is currently pressed
    function sketchpad_mouseMove(e) { 
        // Update the mouse co-ordinates when moved
        getMousePos(e);

        // Draw a dot if the mouse button is currently being pressed
        if (mouseDown==1) {
            drawDot(ctx,mouseX,mouseY,10);
			drawDot(ctx,touchX,touchY,10);
			//drawDot2(ctx2,mouseX,mouseY,20);
			//drawDot2(ctx2,touchX,touchY,20);
			//continuous draw shape
        }
		if (mouseDown==0) {
            
			drawDot2(ctx2,mouseX,mouseY,20);
			drawDot2(ctx2,touchX,touchY,20);
			//continuous draw shape
        }
    }

    // Get the current mouse position relative to the top-left of the canvas
    function getMousePos(e) {
        if (!e)
            var e = event;

        if (e.offsetX) {
            mouseX = e.offsetX;
            mouseY = e.offsetY;
        }
        else if (e.layerX) {
            mouseX = e.layerX;
            mouseY = e.layerY;
        }
     }

    // Draw something when a touch start is detected
    function sketchpad_touchStart() {
        // Update the touch co-ordinates
        getTouchPos();

        drawDot(ctx,touchX,touchY,10);
		drawDot2(ctx2,touchX,touchY,20);

        // Prevents an additional mousedown event being triggered
        event.preventDefault();
    }

    // Draw something and prevent the default scrolling when touch movement is detected
    function sketchpad_touchMove(e) { 
        // Update the touch co-ordinates
        getTouchPos(e);

        // During a touchmove event, unlike a mousemove event, we don't need to check if the touch is engaged, since there will always be contact with the screen by definition.
        drawDot(ctx,touchX,touchY,20); 
		drawDot2(ctx2,touchX,touchY,20); 

        // Prevent a scrolling action as a result of this touchmove triggering.
        event.preventDefault();
    }

    // Get the touch position relative to the top-left of the canvas
    // When we get the raw values of pageX and pageY below, they take into account the scrolling on the page
    // but not the position relative to our target div. We'll adjust them using "target.offsetLeft" and
    // "target.offsetTop" to get the correct values in relation to the top left of the canvas.
    function getTouchPos(e) {
        if (!e)
            var e = event;

        if(e.touches) {
            if (e.touches.length == 1) { // Only deal with one finger
                var touch = e.touches[0]; // Get the information for finger #1
                touchX=touch.pageX-touch.target.offsetLeft;
                touchY=touch.pageY-touch.target.offsetTop;
            }
        }
    }


    // Set-up the canvas and add our event handlers after the page has loaded
    function init() {
        // Get the specific canvas element from the HTML document
        canvas = document.getElementById('sketchpad');

        // If the browser supports the canvas tag, get the 2d drawing context for this canvas
        if (canvas.getContext)
            ctx = canvas.getContext('2d');
		
		if (canvas.getContext)
            ctx2 = canvas.getContext('2d');

        // Check that we have a valid context to draw on/with before adding event handlers
        if (ctx) {
            // React to mouse events on the canvas, and mouseup on the entire document
            canvas.addEventListener('mousedown', sketchpad_mouseDown, false);
            canvas.addEventListener('mousemove', sketchpad_mouseMove, false);
            window.addEventListener('mouseup', sketchpad_mouseUp, false);

            // React to touch events on the canvas
            canvas.addEventListener('touchstart', sketchpad_touchStart, false);
            canvas.addEventListener('touchmove', sketchpad_touchMove, false);
        }
		
		
		
		if (ctx2) {
            // React to mouse events on the canvas, and mouseup on the entire document
            canvas.addEventListener('mousedown', sketchpad_mouseDown, false);
            canvas.addEventListener('mousemove', sketchpad_mouseMove, false);
            window.addEventListener('mouseup', sketchpad_mouseUp, false);

            // React to touch events on the canvas
            canvas.addEventListener('touchstart', sketchpad_touchStart, false);
            canvas.addEventListener('touchmove', sketchpad_touchMove, false);
        }
    }
</script>

<style>
	
/*<div class="leftside">
             
             <input type="submit" value="Clear Sketchpad" id="clearbutton" onclick="clearCanvas(canvas,ctx);">
        </div>
	
	*/
/* Some CSS styling */
#sketchpadapp {
    /* Prevent nearby text being highlighted when accidentally dragging mouse outside confines of the canvas */
    -webkit-touch-callout: none;
    -webkit-user-select: none;
    -khtml-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;
}
.leftside {
    float:left;
    width:150px;
    height:100px;
    background-color:#def;
    padding:10px;
    border-radius:4px;
}
.rightside {
    float:left;
    margin-left:10px;
}
#sketchpad {
    float:left;
    border:1px solid #888;
    border-radius:0px;
    position:absolute; /* Necessary for correct mouse co-ords in Firefox --- relative */
    
    cursor: pointer;
}
#clearbutton {
    font-size: 15px;
    padding: 10px;
    -webkit-appearance: none;
    background: #eee;
    border: 1px solid #888;
}
	
	
#textfloat {
		position="absolute";
		
    width: 50%;
	line-height: 1.5em;
    
	margin-left: 5%;
	margin-left: 5%;
		
	}
		
</style>
</head>

<body onload="init()">
    <div id="sketchpadapp">
        
        <div class="rightside">
            <canvas id="sketchpad" height="700" width=780%>
            </canvas>
        </div>
    </div>
	<div id="textfloat"><br>"one becomes unfit for subjection, because one does not posses the kind of agency that can force the regulatory forces of subjecthood".</div>
</body>
</html>
